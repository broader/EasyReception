<h1><%= chapter %>. HTMLTags - génère du HTML en Python</h1>

<h3><%= chapter %>.1 Vue d'ensemble</h3>

<p>Le module HTMLTags définit une classe pour toutes les balises HTML valides,
écrites en majuscules. Pour créer un élément en HTML, la syntaxe générale 
est :

<p>
<span class="python">
      t = TAG(content, key1=val1,key2=val2,...)
</span>

<p>de façon que <code>print t</code> donnera :

<p>
<span class="browser">
&lt;TAG key1="val1" key2="val2" ...>content&lt;/TAG>
</span>

<p>Par exemple :

<p><span class="python">
print A('bar', href="foo")</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;A href="foo">bar&lt;/A>
</span>

<p>Pour les attributs qui ont le même nom que des mots-clé de Python (<code>class</code>,
<code>type</code>) il faut les écrire avec une majuscule :

<p><span class="python">print DIV('bar', Class="title")</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;DIV Class="title">bar&lt;/A>
</span>

<p>Pour générer des attributs HTML sans valeur, donnez-leur la valeur 
<code>True</code> :

<p><span class="python">print OPTION('foo',SELECTED=True,value=5)</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;OPTION value="5" SELECTED></span>

<p>Pour des balises sans fermeture telles que &lt;IMG&gt; ou &lt;BR&gt;, l'instruction
<code>print</code> ne génère pas de balise fermante

<h3><%= chapter %>.2 Concaténation de balises</h3>

<p>Pour ajouter un "frère" à une balise (un élément au même niveau dans l'arborescence) on se sert de l'opérateur d'addition :

<p>
<span class="python">print B('bar')+INPUT(name="bar")</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;B>bar&lt;/B>&lt;INPUT name="bar"></span>

<p>On peut aussi répéter une instance en utilisant l'opérateur de multiplication :
<p>
<span class="python">print TH('&amp;nbsp')*3</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;TD>&amp;nbsp;&lt;/TD>&lt;TD>&amp;nbsp;&lt;/TD>&lt;TD>&amp;nbsp;&lt;/TD>
</span>

<p>A partir d'une liste d'instances, on peut concaténer les éléments avec la fonction <code>Sum()</code> :

<p>
<span class="python">
Sum([ (I(i)+':'+B(i*i)+BR()) for i in range(100) ])
</span>

<p>génère des lignes avec les carrés des entiers de 0 à 99

<h3><%= chapter %>.3 Construction d'un document HTML</h3>

<p>Un document HTML est un arbre constitué d'éléments ; HTMLTags fournit des moyens simples pour construire cet arbre

<p>L'argument <em>content</em> peut être une instance d'une classe de HTMLTags, il est donc possible d'imbriquer des balises de cette façon :

<p>
<span class="python">print B(I('foo'))</span>
&nbsp;&nbsp;==>
<span class="browser">&lt;B&gt;&lt;I&gt;foo&lt;/I&gt;&lt;/B&gt;</span>

<p>Si on considère le document comme un arbre, cela veut dire que l'instance <code>I('foo')</code> est un fils de l'instance de la classe <code>B</code>

<p>Pour construire un arbre plus complexe, en prenant cette approche il faut faire attention aux parenthèses ouvrantes et fermantes, et le code risque de devenir rapidement difficile à lire et à maintenir. Cela implique aussi qu'on construit l'arbre "par le bas"

<p>Une autre solution est de le construire "par le haut" : construire d'abord le premier élément contenant, puis lui ajouter des descendants. HTMLTags se sert de l'opérateur <code>&lt;=</code> comme synonyme de "ajouter un enfant"

<p>Vous pouvez comparer les deux approches sur cet exemple :
<p>
<ul>
<li>"par le bas"
<p><div class="python">
# construction des lignes en premier
<br>lines = INPUT(name="zone1",value=kw.get("zone1",""))
<br>lines += BR()+INPUT(name="zone2",value=kw.get("zone2",""))
<br>lines += BR()+INPUT(Type="submit",value="Ok")
<br># construction et impression du formulaire
<br>print FORM(lines,action="validate",method="post")
</div>

<p>
<li>"par le haut"
<p><div class="python">
# construction du formulaire en premier
<br>form = FORM(action="validate",method="post") 
<br># ajout des éléments descendants
<br>form <= INPUT(name="zone1",value=kw.get("zone1","")) 
<br>form <= BR()+INPUT(name="zone2",value=kw.get("zone2","")) 
<br>form <= BR()+INPUT(Type="submit",value="Ok") 
<br>print form
</div>
</ul>

<p>Pour construire un document complexe, l'approche par le haut est probablement plus lisible
<p>
<pre class="python">
head = HEAD()
head <= LINK(rel="Stylesheet",href="doc.css")
head <= TITLE('Collection de disques')+stylesheet
&nbsp;
body = BODY()
body <= H1('Ma collection de disques')
&nbsp;
table = TABLE(Class="content")
table <= TR(TH('Titre')+TH('Artiste'))
for rec in records:
    table <= TR(TD(rec.titre,Class="titre")+TD(rec.artiste,Class="artiste")
&nbsp;
body <= table
&nbsp;
print HTML(head+body)
</pre>
<p>
<h3><%= chapter %>.4 Inspection de l'arborescence du document</h3>

<p>Les balises possèdent 2 méthodes qui permettent de retrouver les éléments descendant de la balise et qui satisfont certaines conditions :
<ul>
<li><code>get_by_tag(<i>tag_name</i>)</code> : renvoie la liste des élements descendants qui ont le nom de balise spécifié
<li><code>get_by_attr(<i>arg1=val1,arg2=val2...</i>)</code> : renvoie la liste des éléments descendants dont les attributs satisfont les conditions spécifiées
</ul>

<p>Par exemple, si vous avez construit une table et que vous voulez présenter les lignes paires et impaires dans des styles différents, vous pouvez utiliser <code>get_by_tag()</code> et modifier l'attribut "Class" des balises <code>TD</code> de cette façon :

<p>
<pre class="python">
classes = ['ligne_paire','ligne_impaire']
lignes = table.get_by_tag('TR')
for i,ligne in enumerate(lignes):
    cellules = ligne.get_by_tag('TD')
    for cellule in cellules:
        cellule.attrs['Class'] = classes[i%2]
</pre>

<p>

<h3><%= chapter %>.5 Balises SELECT, cases à cocher et boutons radio</h3>

<p>Quand on construit un document HTML, il y a souvent un ensemble de données (le résultat d'une requête à une base de données par exemple) qui doit être présenté à l'utilisateur comme une liste d'options dans une balise SELECT, ou comme une liste de boutons radio ou de cases à cocher. En général, une ou plusieurs des options est sélectionnée ou cochée parce qu'elle remplit certaines conditions

<p>HTMLTags fournit des méthodes spéciales pour la balise SELECT pour l'initialiser à partir de l'ensemble de données, et pour marquer une ou plusieurs options comme sélectionnée :

<ul>
<li><code>from_list(<i>data</i>)</code> : renvoie la balise SELECT avec les balises OPTION construites à partir de la liste <i>data</i>. Chaque balise OPTION a la valeur de l'élément comme contenu et le rang de l'élément dans la liste comme valeur :

<p>
<span class="python">s = SELECT().from_list(["foo","bar"])
</span>
&nbsp;&nbsp;==>
<div class="browser">&lt;SELECT>
<br>&lt;OPTION value="0">foo
<br>&lt;OPTION value="1">bar
<br>&lt;/SELECT>
</div>

<li><code>select(content=<i>item</i>)</code> ou <code>select(value=<i>item</i>)</code> : marque les options avec le contenu ou la valeur spécifié comme sélectionné, et les autres options comme non sélectionnées. <i>item</i> peut être une liste d'éléments ou de valeurs, pour les balises SELECT qui ont l'option MULTIPLE

<p>
<span class="python">s.select(content="bar")
</span>
&nbsp;&nbsp;==>
<div class="browser">&lt;SELECT>
<br>&lt;OPTION value="0">foo
<br>&lt;OPTION value="1" SELECTED>bar
<br>&lt;/SELECT>
</div>

</ul>

<p>Pour les cases à cocher et les boutons radio, HTMLTags fournit 2 classes, <code>CHECKBOX</code> et <code>RADIO</code>. Les instances de ces deux classes sont initialisées avec une liste comme premier argument, et les attributs des balises INPUT comme autres arguments par mots-clés :

<p>
<span class="python">radio = RADIO(["foo","bar"],Class="menu")
</span>

<p>L'itération sur une instance de RADIO produit des tuples <code><i>(contenu,balise)</i></code>&nbsp; où <i>contenu</i> est l'élément de la liste originale :

<p>
<pre class="python">for (contenu,balise) in radio:
    print contenu,balise
</pre>
&nbsp;&nbsp;==>
<p>
<div class="browser">
foo&lt;INPUT Type="radio" Class="menu" value="0">
<br>bar&lt;INPUT Type="radio" Class="menu" value="1">
</div>
<p>Quand l'instance est créée, toutes les balises INPUT sont décochées. La méthode <code>check(content=<i>item</i>)</code> ou <code>check(value=<i>item</i>)</code> est utilisée pour cocher les balises INPUT qui ont le contenu ou la valeur spécifié

<p>
<pre class="python">radio.check(content="foo")
table = TABLE()
for (contenu,balise) in radio:
    table <= TR(TD(contenu)+TD(balise))
print table
</pre>
&nbsp;&nbsp;==>
<p>
<pre class="browser">
&lt;TABLE&gt;
&lt;TR&gt;
&lt;TD&gt;foo&lt;/TD&gt;
&lt;TD&gt;&lt;INPUT Type="radio" Class="menu" value="0"&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
&lt;TD&gt;bar&lt;/TD&gt;
&lt;TD&gt;&lt;INPUT Type="radio" Class="menu" value="1"&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
</pre>

<p>Comme pour <code>SELECT</code>, <i>item</i> peut être une liste d'éléments ou de valeurs, dans le cas où on veut cocher plusieurs cases à cocher

<h3><%= chapter %>.6 Unicode</h3>

<p>Le contenu et les valeurs d'attributs peuvent être indifféremment des chaînes d'octets ou des chaînes Unicode. Quand une balise est imprimée, les chaînes Unicode sont encodées en chaînes d'octets. L'encodage est défini par la fonction <code>set_encoding(<i>encodage</i>)</code>
<p>Si vous ne spécifiez pas d'encodage, la valeur par défaut du système (<code>sys.getdefaultencoding()</code>) est utilisée
<p>Dans les scripts Karrigell, l'encodage défini par <code>SET_UNICODE_OUT()</code> est aussi utilisé par HTMLTags - il n'est pas nécessaire d'utiliser en plus la fonction <code>set_encoding()</code>
</pre>